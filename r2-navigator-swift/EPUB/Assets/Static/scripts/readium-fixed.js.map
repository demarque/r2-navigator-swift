{"version":3,"sources":["webpack://readium-js/./node_modules/approx-string-match/dist/index.js","webpack://readium-js/./src/gestures.js","webpack://readium-js/webpack/bootstrap","webpack://readium-js/./src/selection.js","webpack://readium-js/./src/rect.js","webpack://readium-js/./src/highlight.js","webpack://readium-js/./src/vendor/hypothesis/anchoring/match-quote.js","webpack://readium-js/./src/vendor/hypothesis/anchoring/text-range.js","webpack://readium-js/./src/vendor/hypothesis/anchoring/types.js","webpack://readium-js/./src/utils.js","webpack://readium-js/./src/index.js"],"names":["reverse","s","split","join","oneIfNotZero","n","advanceBlock","ctx","peq","b","hIn","pV","P","mV","M","hInIsNegative","eq","xV","xH","pH","mH","hOut","lastRowMask","findMatchEnds","text","pattern","maxErrors","length","Math","min","matches","w","bMax","ceil","Uint32Array","fill","emptyPeq","Map","asciiPeq","i","push","c","val","charCodeAt","has","charPeq","set","r","idx","y","max","score","j","charCode","get","carry","maxBlockScore","splice","start","end","errors","exports","patRev","map","m","minStart","slice","reduce","rm","findMatchStarts","onClick","event","window","getSelection","isCollapsed","webkit","messageHandlers","tap","postMessage","defaultPrevented","screenX","screenY","clientX","clientY","target","outerHTML","nearestInteractiveElement","element","indexOf","nodeName","toLowerCase","hasAttribute","getAttribute","parentElement","addEventListener","document","body","style","cursor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","createOrderedRange","startNode","startOffset","endNode","endOffset","range","Range","setStart","setEnd","collapsed","log","rangeReverse","rangeInfo2Location","rangeInfo","cssSelector","startContainerElementCssSelector","domRange","textNodeIndex","startContainerChildTextNodeIndex","offset","endContainerElementCssSelector","endContainerChildTextNodeIndex","fullQualifiedSelector","node","nodeType","Node","ELEMENT_NODE","localName","optimized","steps","contextNode","step","_cssPathStep","value","parentNode","cssPath","isTargetNode","idSelector","idd","escapeIdentifierIfNeeded","ident","test","shouldEscapeFirst","lastIndex","replace","ii","isCSSIdentChar","isLast","hexByte","toString","toHexByte","escapeAsciiChar","prefixedElementClassNames","nd","classAttribute","filter","Boolean","nm","lowerCaseName","id","parent","DOCUMENT_NODE","prefixedOwnClassNamesArray_","prefixedOwnClassNamesArray","forEach","arrItem","needsClassNames","needsNthChild","ownIndex","elementIndex","siblings","children","sibling","ownClassNames","ownClassNameCount","siblingClassNamesArray_","siblingClassNamesArray","siblingClass","ind","result","prefixedName","substr","arguments","doNotMergeHorizontallyAlignedRects","clientRects","getClientRects","originalRects","rangeClientRect","bottom","height","left","right","top","width","newRects","replaceOverlapingRects","rects","tolerance","rectsToKeep","Set","rect","possiblyContainingRect","rectContains","delete","Array","from","removeContainedRects","mergeTouchingRects","rect1","rect2","rectsLineUpVertically","almostEqual","rectsLineUpHorizontally","horizontalAllowed","rectsTouchOrOverlap","replacementClientRect","getBoundingRect","rectContainsPoint","x","toRemove","toPreserve","toAdd","subtractRects1","rectSubtract","subtractRects2","prototype","apply","rectIntersected","maxLeft","minRight","maxTop","minBottom","rectIntersect","rectA","rectB","rectC","rectD","a","abs","_highlights","_highlightsContainer","defaultBackgroundColor","blue","green","red","createHighlightRange","Date","now","destroyHighlight","highlight","color","pointerInteraction","createHighlightFromRange","_document","find","h","highlightContainer","getElementById","remove","scale","READIUM2","isFixedLayout","fxlViewportScale","scrollElement","scrollingElement","paginated","documentElement","getPropertyValue","trim","highlightsContainer","win","createElement","setAttribute","setProperty","append","ensureContainer","highlightParent","bodyRect","getBoundingClientRect","xOffset","yOffset","scrollLeft","scrollTop","clientRect","highlightArea","position","highlightBounding","rangeBoundingClientRect","search","str","matchPos","exactMatches","textMatchScore","nodeTextLength","TEXT_NODE","previousSiblingsTextLength","previousSibling","resolveOffsets","offsets","nextOffset","shift","nodeIter","createNodeIterator","NodeFilter","SHOW_TEXT","results","textNode","currentNode","nextNode","data","RangeError","Error","this","contains","el","options","err","direction","tw","createTreeWalker","getRootNode","forwards","previousNode","fromPoint","textOffset","childNodes","relativeTo","resolve","startContainer","endContainer","root","TextPositionAnchor","textRange","selector","type","toRange","TextQuoteAnchor","exact","context","prefix","suffix","toPositionAnchor","match","quote","scoreMatch","quoteScore","prefixScore","suffixScore","posScore","hint","quoteWeight","scoredMatches","sort","matchQuote","logError","message","filename","lineno","orientationChanged","snapCurrentPosition","func","timeout","last_known_scrollX_position","last_known_scrollY_position","ticking","maxScreenX","orientation","screen","scrollToOffset","currentOffset","scrollX","pageWidth","innerWidth","snapOffset","currentOffsetSnapped","call","e","scrollY","scrollHeight","scrollWidth","requestAnimationFrame","positionString","progressionChanged","info","selection","rangeCount","getRangeAt","selectionChanged","self","args","callback","clearTimeout","setTimeout","readium","scrollIntoView","dir","console","before","after","innerHeight","isRTL","documentWidth","minOffset","maxOffset","key","removeProperty","sel","screenWidth","outerWidth","screenHeight","outerHeight","logException","rawText","anchorNode","focusNode","anchorOffset","focusOffset","getCssSelector","startIsElement","startContainerElement","endIsElement","endContainerElement","commonElementAncestor","node1","node2","node1ElementAncestorChain","node2ElementAncestorChain","commonAncestor","node1ElementAncestor","node2ElementAncestor","getCommonAncestorElement","commonAncestorContainer","rangeCommonAncestorElement","convertRange","locations","location","location2RangeInfo","startElement","querySelector","endElement","createHighlightDom"],"mappings":"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","file":"readium-fixed.js","sourcesContent":["\"use strict\";\n/**\n * Implementation of Myers' online approximate string matching algorithm [1],\n * with additional optimizations suggested by [2].\n *\n * This has O((k/w) * n) complexity where `n` is the length of the text, `k` is\n * the maximum number of errors allowed (always <= the pattern length) and `w`\n * is the word size. Because JS only supports bitwise operations on 32 bit\n * integers, `w` is 32.\n *\n * As far as I am aware, there aren't any online algorithms which are\n * significantly better for a wide range of input parameters. The problem can be\n * solved faster using \"filter then verify\" approaches which first filter out\n * regions of the text that cannot match using a \"cheap\" check and then verify\n * the remaining potential matches. The verify step requires an algorithm such\n * as this one however.\n *\n * The algorithm's approach is essentially to optimize the classic dynamic\n * programming solution to the problem by computing columns of the matrix in\n * word-sized chunks (ie. dealing with 32 chars of the pattern at a time) and\n * avoiding calculating regions of the matrix where the minimum error count is\n * guaranteed to exceed the input threshold.\n *\n * The paper consists of two parts, the first describes the core algorithm for\n * matching patterns <= the size of a word (implemented by `advanceBlock` here).\n * The second uses the core algorithm as part of a larger block-based algorithm\n * to handle longer patterns.\n *\n * [1] G. Myers, “A Fast Bit-Vector Algorithm for Approximate String Matching\n * Based on Dynamic Programming,” vol. 46, no. 3, pp. 395–415, 1999.\n *\n * [2] Šošić, M. (2014). An simd dynamic programming c/c++ library (Doctoral\n * dissertation, Fakultet Elektrotehnike i računarstva, Sveučilište u Zagrebu).\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction reverse(s) {\n    return s\n        .split(\"\")\n        .reverse()\n        .join(\"\");\n}\n/**\n * Given the ends of approximate matches for `pattern` in `text`, find\n * the start of the matches.\n *\n * @param findEndFn - Function for finding the end of matches in\n * text.\n * @return Matches with the `start` property set.\n */\nfunction findMatchStarts(text, pattern, matches) {\n    var patRev = reverse(pattern);\n    return matches.map(function (m) {\n        // Find start of each match by reversing the pattern and matching segment\n        // of text and searching for an approx match with the same number of\n        // errors.\n        var minStart = Math.max(0, m.end - pattern.length - m.errors);\n        var textRev = reverse(text.slice(minStart, m.end));\n        // If there are multiple possible start points, choose the one that\n        // maximizes the length of the match.\n        var start = findMatchEnds(textRev, patRev, m.errors).reduce(function (min, rm) {\n            if (m.end - rm.end < min) {\n                return m.end - rm.end;\n            }\n            return min;\n        }, m.end);\n        return {\n            start: start,\n            end: m.end,\n            errors: m.errors\n        };\n    });\n}\n/**\n * Return 1 if a number is non-zero or zero otherwise, without using\n * conditional operators.\n *\n * This should get inlined into `advanceBlock` below by the JIT.\n *\n * Adapted from https://stackoverflow.com/a/3912218/434243\n */\nfunction oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n}\n/**\n * Block calculation step of the algorithm.\n *\n * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n * checks with bitwise operations as per Section 4.2.3 of [2].\n *\n * @param ctx - The pattern context object\n * @param peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n * @param b - The block level\n * @param hIn - Horizontal input delta ∈ {1,0,-1}\n * @return Horizontal output delta ∈ {1,0,-1}\n */\nfunction advanceBlock(ctx, peq, b, hIn) {\n    var pV = ctx.P[b];\n    var mV = ctx.M[b];\n    var hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    var eq = peq[b] | hInIsNegative;\n    // Step 1: Compute horizontal deltas.\n    var xV = eq | mV;\n    var xH = (((eq & pV) + pV) ^ pV) | eq;\n    var pH = mV | ~(xH | pV);\n    var mH = pV & xH;\n    // Step 2: Update score (value of last row of this block).\n    var hOut = oneIfNotZero(pH & ctx.lastRowMask[b]) -\n        oneIfNotZero(mH & ctx.lastRowMask[b]);\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // set pH[0] if hIn > 0\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n    return hOut;\n}\n/**\n * Find the ends and error counts for matches of `pattern` in `text`.\n *\n * Only the matches with the lowest error count are reported. Other matches\n * with error counts <= maxErrors are discarded.\n *\n * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n */\nfunction findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n        return [];\n    }\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n    var matches = [];\n    // Word size.\n    var w = 32;\n    // Index of maximum block level.\n    var bMax = Math.ceil(pattern.length / w) - 1;\n    // Context used across block calculations.\n    var ctx = {\n        P: new Uint32Array(bMax + 1),\n        M: new Uint32Array(bMax + 1),\n        lastRowMask: new Uint32Array(bMax + 1)\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n    // Dummy \"peq\" array for chars in the text which do not occur in the pattern.\n    var emptyPeq = new Uint32Array(bMax + 1);\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    var peq = new Map();\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    var asciiPeq = [];\n    for (var i = 0; i < 256; i++) {\n        asciiPeq.push(emptyPeq);\n    }\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (var c = 0; c < pattern.length; c += 1) {\n        var val = pattern.charCodeAt(c);\n        if (peq.has(val)) {\n            // Duplicate char in pattern.\n            continue;\n        }\n        var charPeq = new Uint32Array(bMax + 1);\n        peq.set(val, charPeq);\n        if (val < asciiPeq.length) {\n            asciiPeq[val] = charPeq;\n        }\n        for (var b = 0; b <= bMax; b += 1) {\n            charPeq[b] = 0;\n            // Set all the bits where the pattern matches the current char (ch).\n            // For indexes beyond the end of the pattern, always set the bit as if the\n            // pattern contained a wildcard char in that position.\n            for (var r = 0; r < w; r += 1) {\n                var idx = b * w + r;\n                if (idx >= pattern.length) {\n                    continue;\n                }\n                var match = pattern.charCodeAt(idx) === val;\n                if (match) {\n                    charPeq[b] |= 1 << r;\n                }\n            }\n        }\n    }\n    // Index of last-active block level in the column.\n    var y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n    // Initialize maximum error count at bottom of each block.\n    var score = new Uint32Array(bMax + 1);\n    for (var b = 0; b <= y; b += 1) {\n        score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n    // Initialize vertical deltas for each block.\n    for (var b = 0; b <= y; b += 1) {\n        ctx.P[b] = ~0;\n        ctx.M[b] = 0;\n    }\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (var j = 0; j < text.length; j += 1) {\n        // Lookup the bitmask representing the positions of the current char from\n        // the text within the pattern.\n        var charCode = text.charCodeAt(j);\n        var charPeq = void 0;\n        if (charCode < asciiPeq.length) {\n            // Fast array lookup.\n            charPeq = asciiPeq[charCode];\n        }\n        else {\n            // Slower hash table lookup.\n            charPeq = peq.get(charCode);\n            if (typeof charPeq === \"undefined\") {\n                charPeq = emptyPeq;\n            }\n        }\n        // Calculate error count for blocks that we definitely have to process for\n        // this column.\n        var carry = 0;\n        for (var b = 0; b <= y; b += 1) {\n            carry = advanceBlock(ctx, charPeq, b, carry);\n            score[b] += carry;\n        }\n        // Check if we also need to compute an additional block, or if we can reduce\n        // the number of blocks processed for the next column.\n        if (score[y] - carry <= maxErrors &&\n            y < bMax &&\n            (charPeq[y + 1] & 1 || carry < 0)) {\n            // Error count for bottom block is under threshold, increase the number of\n            // blocks processed for this column & next by 1.\n            y += 1;\n            ctx.P[y] = ~0;\n            ctx.M[y] = 0;\n            var maxBlockScore = y === bMax ? pattern.length % w : w;\n            score[y] =\n                score[y - 1] +\n                    maxBlockScore -\n                    carry +\n                    advanceBlock(ctx, charPeq, y, carry);\n        }\n        else {\n            // Error count for bottom block exceeds threshold, reduce the number of\n            // blocks processed for the next column.\n            while (y > 0 && score[y] >= maxErrors + w) {\n                y -= 1;\n            }\n        }\n        // If error count is under threshold, report a match.\n        if (y === bMax && score[y] <= maxErrors) {\n            if (score[y] < maxErrors) {\n                // Discard any earlier, worse matches.\n                matches.splice(0, matches.length);\n            }\n            matches.push({\n                start: -1,\n                end: j + 1,\n                errors: score[y]\n            });\n            // Because `search` only reports the matches with the lowest error count,\n            // we can \"ratchet down\" the max error threshold whenever a match is\n            // encountered and thereby save a small amount of work for the remainder\n            // of the text.\n            maxErrors = score[y];\n        }\n    }\n    return matches;\n}\n/**\n * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n *\n * Returns the start, and end positions and error counts for each lowest-cost\n * match. Only the \"best\" matches are returned.\n */\nfunction search(text, pattern, maxErrors) {\n    var matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n}\nexports.default = search;\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nwindow.addEventListener('DOMContentLoaded', function(event) {\n  // If we don't set the CSS cursor property to pointer, then the click events are not triggered pre-iOS 13.\n  document.body.style.cursor = 'pointer';\n\n  document.addEventListener('click', onClick, false);\n});\n\nfunction onClick(event) {\n\n  if (!window.getSelection().isCollapsed) {\n    // There's an on-going selection, the tap will dismiss it so we don't forward it.\n    return;\n  }\n\n  // Send the tap data over the JS bridge even if it's been handled\n  // within the webview, so that it can be preserved and used\n  // by the WKNavigationDelegate if needed.\n  webkit.messageHandlers.tap.postMessage({\n    \"defaultPrevented\": event.defaultPrevented,\n    \"screenX\": event.screenX,\n    \"screenY\": event.screenY,\n    \"clientX\": event.clientX,\n    \"clientY\": event.clientY,\n    \"targetElement\": event.target.outerHTML,\n    \"interactiveElement\": nearestInteractiveElement(event.target),\n  });\n\n  // We don't want to disable the default WebView behavior as it breaks some features without bringing any value.\n//    event.stopPropagation();\n//    event.preventDefault();\n}\n\n// See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\nfunction nearestInteractiveElement(element) {\n  var interactiveTags = [\n    'a',\n    'audio',\n    'button',\n    'canvas',\n    'details',\n    'input',\n    'label',\n    'option',\n    'select',\n    'submit',\n    'textarea',\n    'video',\n  ]\n  if (interactiveTags.indexOf(element.nodeName.toLowerCase()) !== -1) {\n    return element.outerHTML;\n  }\n\n  // Checks whether the element is editable by the user.\n  if (element.hasAttribute('contenteditable') && element.getAttribute('contenteditable').toLowerCase() != 'false') {\n    return element.outerHTML;\n  }\n\n  // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n  if (element.parentElement) {\n    return nearestInteractiveElement(element.parentElement);\n  }\n\n  return null;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {log as logNative, logException} from \"./utils\";\n\nconst debug = true;\n\nexport function getSelectionRect() {\n    try {\n        let sel = window.getSelection();\n        if (!sel) {\n            return;\n        }\n        let range = sel.getRangeAt(0);\n\n        const clientRect = range.getBoundingClientRect();\n\n        return {\n            screenWidth: window.outerWidth,\n            screenHeight: window.outerHeight,\n            left: clientRect.left,\n            width: clientRect.width,\n            top: clientRect.top,\n            height: clientRect.height\n        };\n    } catch (e) {\n        logException(e)\n        return null;\n    }\n}\n\nexport function getCurrentSelectionInfo() {\n    const selection = window.getSelection();\n    if (!selection) {\n        return undefined;\n    }\n    if (selection.isCollapsed) {\n        log(\"^^^ SELECTION COLLAPSED.\");\n        return undefined;\n    }\n    const rawText = selection.toString();\n    const cleanText = rawText.trim().replace(/\\n/g, \" \").replace(/\\s\\s+/g, \" \");\n    if (cleanText.length === 0) {\n        log(\"^^^ SELECTION TEXT EMPTY.\");\n        return undefined;\n    }\n    if (!selection.anchorNode || !selection.focusNode) {\n        return undefined;\n    }\n    const range = selection.rangeCount === 1 ? selection.getRangeAt(0) :\n        createOrderedRange(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n    if (!range || range.collapsed) {\n        log(\"$$$$$$$$$$$$$$$$$ CANNOT GET NON-COLLAPSED SELECTION RANGE?!\");\n        return undefined;\n    }\n    const rangeInfo = convertRange(range, fullQualifiedSelector);\n    if (!rangeInfo) {\n        log(\"^^^ SELECTION RANGE INFO FAIL?!\");\n        return undefined;\n    }\n\n    return {\n        locations: rangeInfo2Location(rangeInfo),\n        text: {\n            highlight: rawText\n        }\n    };\n}\n\nfunction createOrderedRange(startNode, startOffset, endNode, endOffset) {\n    const range = new Range();\n    range.setStart(startNode, startOffset);\n    range.setEnd(endNode, endOffset);\n    if (!range.collapsed) {\n        return range;\n    }\n    log(\">>> createOrderedRange COLLAPSED ... RANGE REVERSE?\");\n    const rangeReverse = new Range();\n    rangeReverse.setStart(endNode, endOffset);\n    rangeReverse.setEnd(startNode, startOffset);\n    if (!rangeReverse.collapsed) {\n        log(\">>> createOrderedRange RANGE REVERSE OK.\");\n        return range;\n    }\n    log(\">>> createOrderedRange RANGE REVERSE ALSO COLLAPSED?!\");\n    return undefined;\n}\n\nfunction convertRange(range, getCssSelector) {\n    const startIsElement = range.startContainer.nodeType === Node.ELEMENT_NODE;\n    const startContainerElement = startIsElement ?\n        range.startContainer :\n        ((range.startContainer.parentNode && range.startContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.startContainer.parentNode : undefined);\n    if (!startContainerElement) {\n        return undefined;\n    }\n    const startContainerChildTextNodeIndex = startIsElement ? -1 :\n        Array.from(startContainerElement.childNodes).indexOf(range.startContainer);\n    if (startContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const startContainerElementCssSelector = getCssSelector(startContainerElement);\n\n    const endIsElement = range.endContainer.nodeType === Node.ELEMENT_NODE;\n    const endContainerElement = endIsElement ?\n        range.endContainer :\n        ((range.endContainer.parentNode && range.endContainer.parentNode.nodeType === Node.ELEMENT_NODE) ?\n            range.endContainer.parentNode : undefined);\n    if (!endContainerElement) {\n        return undefined;\n    }\n    const endContainerChildTextNodeIndex = endIsElement ? -1 :\n        Array.from(endContainerElement.childNodes).indexOf(range.endContainer);\n    if (endContainerChildTextNodeIndex < -1) {\n        return undefined;\n    }\n    const endContainerElementCssSelector = getCssSelector(endContainerElement);\n\n    const commonElementAncestor = getCommonAncestorElement(range.startContainer, range.endContainer);\n    if (!commonElementAncestor) {\n        log(\"^^^ NO RANGE COMMON ANCESTOR?!\");\n        return undefined;\n    }\n    if (range.commonAncestorContainer) {\n        const rangeCommonAncestorElement = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ?\n            range.commonAncestorContainer : range.commonAncestorContainer.parentNode;\n        if (rangeCommonAncestorElement && rangeCommonAncestorElement.nodeType === Node.ELEMENT_NODE) {\n            if (commonElementAncestor !== rangeCommonAncestorElement) {\n                log(\">>>>>> COMMON ANCESTOR CONTAINER DIFF??!\");\n                log(getCssSelector(commonElementAncestor));\n                log(getCssSelector(rangeCommonAncestorElement));\n            }\n        }\n    }\n    return {\n        endContainerChildTextNodeIndex,\n        endContainerElementCssSelector,\n        endOffset: range.endOffset,\n        startContainerChildTextNodeIndex,\n        startContainerElementCssSelector,\n        startOffset: range.startOffset,\n    };\n}\n\nfunction getCommonAncestorElement(node1, node2) {\n    if (node1.nodeType === Node.ELEMENT_NODE && node1 === node2) {\n        return node1;\n    }\n    if (node1.nodeType === Node.ELEMENT_NODE && node1.contains(node2)) {\n        return node1;\n    }\n    if (node2.nodeType === Node.ELEMENT_NODE && node2.contains(node1)) {\n        return node2;\n    }\n    const node1ElementAncestorChain = [];\n    let parent = node1.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node1ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    const node2ElementAncestorChain = [];\n    parent = node2.parentNode;\n    while (parent && parent.nodeType === Node.ELEMENT_NODE) {\n        node2ElementAncestorChain.push(parent);\n        parent = parent.parentNode;\n    }\n    let commonAncestor = node1ElementAncestorChain.find((node1ElementAncestor) => {\n        return node2ElementAncestorChain.indexOf(node1ElementAncestor) >= 0;\n    });\n    if (!commonAncestor) {\n        commonAncestor = node2ElementAncestorChain.find((node2ElementAncestor) => {\n            return node1ElementAncestorChain.indexOf(node2ElementAncestor) >= 0;\n        });\n    }\n    return commonAncestor;\n}\n\nexport function convertRangeInfo(document, rangeInfo) {\n    const startElement = document.querySelector(rangeInfo.startContainerElementCssSelector);\n    if (!startElement) {\n        log(\"^^^ convertRangeInfo NO START ELEMENT CSS SELECTOR?!\");\n        return undefined;\n    }\n    let startContainer = startElement;\n    if (rangeInfo.startContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length) {\n            log(\"^^^ convertRangeInfo rangeInfo.startContainerChildTextNodeIndex >= startElement.childNodes.length?!\");\n            return undefined;\n        }\n        startContainer = startElement.childNodes[rangeInfo.startContainerChildTextNodeIndex];\n        if (startContainer.nodeType !== Node.TEXT_NODE) {\n            log(\"^^^ convertRangeInfo startContainer.nodeType !== Node.TEXT_NODE?!\");\n            return undefined;\n        }\n    }\n    const endElement = document.querySelector(rangeInfo.endContainerElementCssSelector);\n    if (!endElement) {\n        log(\"^^^ convertRangeInfo NO END ELEMENT CSS SELECTOR?!\");\n        return undefined;\n    }\n    let endContainer = endElement;\n    if (rangeInfo.endContainerChildTextNodeIndex >= 0) {\n        if (rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length) {\n            log(\"^^^ convertRangeInfo rangeInfo.endContainerChildTextNodeIndex >= endElement.childNodes.length?!\");\n            return undefined;\n        }\n        endContainer = endElement.childNodes[rangeInfo.endContainerChildTextNodeIndex];\n        if (endContainer.nodeType !== Node.TEXT_NODE) {\n            log(\"^^^ convertRangeInfo endContainer.nodeType !== Node.TEXT_NODE?!\");\n            return undefined;\n        }\n    }\n    return createOrderedRange(startContainer, rangeInfo.startOffset, endContainer, rangeInfo.endOffset);\n}\n\nfunction rangeInfo2Location(rangeInfo) {\n    return {\n        cssSelector: rangeInfo.startContainerElementCssSelector,\n        domRange: {\n            start: {\n                cssSelector: rangeInfo.startContainerElementCssSelector,\n                textNodeIndex: rangeInfo.startContainerChildTextNodeIndex,\n                offset: rangeInfo.startOffset\n            },\n            end: {\n                cssSelector: rangeInfo.endContainerElementCssSelector,\n                textNodeIndex: rangeInfo.endContainerChildTextNodeIndex,\n                offset: rangeInfo.endOffset\n            }\n        }\n    }\n}\n\nexport function location2RangeInfo(location) {\n    const locations = location.locations\n    const domRange = locations.domRange\n    const start = domRange.start\n    const end = domRange.end\n\n    return {\n        endContainerChildTextNodeIndex: end.textNodeIndex,\n        endContainerElementCssSelector: end.cssSelector,\n        endOffset: end.offset,\n        startContainerChildTextNodeIndex: start.textNodeIndex,\n        startContainerElementCssSelector: start.cssSelector,\n        startOffset: start.offset\n    };\n}\n\nfunction fullQualifiedSelector(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return (node.localName && node.localName.toLowerCase())\n            || node.nodeName.toLowerCase();\n    }\n    //return cssPath(node, justSelector);\n    return cssPath(node, true);\n}\n\nfunction cssPath(node, optimized) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return \"\";\n    }\n\n    const steps = [];\n    let contextNode = node;\n    while (contextNode) {\n        const step = _cssPathStep(contextNode, !!optimized, contextNode === node);\n        if (!step) {\n            break; // Error - bail out early.\n        }\n        steps.push(step.value);\n        if (step.optimized) {\n            break;\n        }\n        contextNode = contextNode.parentNode;\n    }\n    steps.reverse();\n    return steps.join(\" > \");\n}\n\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/devtools/front_end/components/DOMPresentationUtils.js#316\nfunction _cssPathStep(node, optimized, isTargetNode) {\n\n    function idSelector(idd) {\n        return \"#\" + escapeIdentifierIfNeeded(idd);\n    }\n\n    function escapeIdentifierIfNeeded(ident) {\n        if (isCSSIdentifier(ident)) {\n            return ident;\n        }\n\n        const shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);\n        const lastIndex = ident.length - 1;\n        return ident.replace(/./g, function (c, ii) {\n            return ((shouldEscapeFirst && ii === 0) || !isCSSIdentChar(c)) ? escapeAsciiChar(c, ii === lastIndex) : c;\n        });\n    }\n\n    function isCSSIdentifier(value) {\n        return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);\n    }\n\n    function isCSSIdentChar(c) {\n        if (/[a-zA-Z0-9_-]/.test(c)) {\n            return true;\n        }\n        return c.charCodeAt(0) >= 0xA0;\n    }\n\n    function escapeAsciiChar(c, isLast) {\n        return \"\\\\\" + toHexByte(c) + (isLast ? \"\" : \" \");\n    }\n\n    function toHexByte(c) {\n        let hexByte = c.charCodeAt(0).toString(16);\n        if (hexByte.length === 1) {\n            hexByte = \"0\" + hexByte;\n        }\n        return hexByte;\n    }\n\n    function prefixedElementClassNames(nd) {\n        const classAttribute = nd.getAttribute(\"class\");\n        if (!classAttribute) {\n            return [];\n        }\n\n        return classAttribute.split(/\\s+/g).filter(Boolean).map((nm) => {\n            // The prefix is required to store \"__proto__\" in a object-based map.\n            return \"$\" + nm;\n        });\n    }\n\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n    const lowerCaseName = (node.localName && node.localName.toLowerCase())\n        || node.nodeName.toLowerCase();\n\n    const element = node;\n\n    const id = element.getAttribute(\"id\");\n\n    if (optimized) {\n        if (id) {\n            return {\n                optimized: true,\n                value: idSelector(id),\n            };\n        }\n        if (lowerCaseName === \"body\" || lowerCaseName === \"head\" || lowerCaseName === \"html\") {\n            return {\n                optimized: true,\n                value: lowerCaseName, // node.nodeNameInCorrectCase(),\n            };\n        }\n    }\n\n    const nodeName = lowerCaseName; // node.nodeNameInCorrectCase();\n    if (id) {\n        return {\n            optimized: true,\n            value: nodeName + idSelector(id),\n        };\n    }\n\n    const parent = node.parentNode;\n\n    if (!parent || parent.nodeType === Node.DOCUMENT_NODE) {\n        return {\n            optimized: true,\n            value: nodeName,\n        };\n    }\n\n    const prefixedOwnClassNamesArray_ = prefixedElementClassNames(element);\n\n    const prefixedOwnClassNamesArray = []; // .keySet()\n    prefixedOwnClassNamesArray_.forEach((arrItem) => {\n        if (prefixedOwnClassNamesArray.indexOf(arrItem) < 0) {\n            prefixedOwnClassNamesArray.push(arrItem);\n        }\n    });\n\n    let needsClassNames = false;\n    let needsNthChild = false;\n    let ownIndex = -1;\n    let elementIndex = -1;\n    const siblings = parent.children;\n\n    for (let i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {\n        const sibling = siblings[i];\n        if (sibling.nodeType !== Node.ELEMENT_NODE) {\n            continue;\n        }\n        elementIndex += 1;\n        if (sibling === node) {\n            ownIndex = elementIndex;\n            continue;\n        }\n        if (needsNthChild) {\n            continue;\n        }\n\n        // sibling.nodeNameInCorrectCase()\n        const siblingName = (sibling.localName && sibling.localName.toLowerCase()) || sibling.nodeName.toLowerCase();\n        if (siblingName !== nodeName) {\n            continue;\n        }\n        needsClassNames = true;\n\n        const ownClassNames = [];\n        prefixedOwnClassNamesArray.forEach((arrItem) => {\n            ownClassNames.push(arrItem);\n        });\n        let ownClassNameCount = ownClassNames.length;\n\n        if (ownClassNameCount === 0) {\n            needsNthChild = true;\n            continue;\n        }\n        const siblingClassNamesArray_ = prefixedElementClassNames(sibling);\n        const siblingClassNamesArray = []; // .keySet()\n        siblingClassNamesArray_.forEach((arrItem) => {\n            if (siblingClassNamesArray.indexOf(arrItem) < 0) {\n                siblingClassNamesArray.push(arrItem);\n            }\n        });\n\n        for (const siblingClass of siblingClassNamesArray) {\n            const ind = ownClassNames.indexOf(siblingClass);\n            if (ind < 0) {\n                continue;\n            }\n\n            ownClassNames.splice(ind, 1); // delete ownClassNames[siblingClass];\n\n            if (!--ownClassNameCount) {\n                needsNthChild = true;\n                break;\n            }\n        }\n    }\n\n    let result = nodeName;\n    if (isTargetNode &&\n        nodeName === \"input\" &&\n        element.getAttribute(\"type\") &&\n        !element.getAttribute(\"id\") &&\n        !element.getAttribute(\"class\")) {\n        result += \"[type=\\\"\" + element.getAttribute(\"type\") + \"\\\"]\";\n    }\n    if (needsNthChild) {\n        result += \":nth-child(\" + (ownIndex + 1) + \")\";\n    } else if (needsClassNames) {\n        for (const prefixedName of prefixedOwnClassNamesArray) {\n            result += \".\" + escapeIdentifierIfNeeded(prefixedName.substr(1));\n        }\n    }\n\n    return {\n        optimized: false,\n        value: result,\n    };\n}\n\nfunction log() {\n    if (debug) {\n        logNative.apply(null, arguments);\n    }\n}","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {log as logNative} from \"./utils\";\n\nconst debug = false;\n\nexport function getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects) {\n    let clientRects = range.getClientRects();\n\n    const tolerance = 1;\n    const originalRects = [];\n    for (const rangeClientRect of clientRects) {\n        originalRects.push({\n            bottom: rangeClientRect.bottom,\n            height: rangeClientRect.height,\n            left: rangeClientRect.left,\n            right: rangeClientRect.right,\n            top: rangeClientRect.top,\n            width: rangeClientRect.width,\n        });\n    }\n    const mergedRects = mergeTouchingRects(originalRects, tolerance, doNotMergeHorizontallyAlignedRects);\n    const noContainedRects = removeContainedRects(mergedRects, tolerance);\n    const newRects = replaceOverlapingRects(noContainedRects);\n    const minArea = 2 * 2;\n    for (let j = newRects.length - 1; j >= 0; j--) {\n        const rect = newRects[j];\n        const bigEnough = (rect.width * rect.height) > minArea;\n        if (!bigEnough) {\n            if (newRects.length > 1) {\n                log(\"CLIENT RECT: remove small\");\n                newRects.splice(j, 1);\n            } else {\n                log(\"CLIENT RECT: remove small, but keep otherwise empty!\");\n                break;\n            }\n        }\n    }\n    log(`CLIENT RECT: reduced ${originalRects.length} --> ${newRects.length}`);\n    return newRects;\n}\n\nfunction mergeTouchingRects(rects, tolerance, doNotMergeHorizontallyAlignedRects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                log(\"mergeTouchingRects rect1 === rect2 ??!\");\n                continue;\n            }\n            const rectsLineUpVertically = almostEqual(rect1.top, rect2.top, tolerance) &&\n                almostEqual(rect1.bottom, rect2.bottom, tolerance);\n            const rectsLineUpHorizontally = almostEqual(rect1.left, rect2.left, tolerance) &&\n                almostEqual(rect1.right, rect2.right, tolerance);\n            const horizontalAllowed = !doNotMergeHorizontallyAlignedRects;\n            const aligned = (rectsLineUpHorizontally && horizontalAllowed) || (rectsLineUpVertically && !rectsLineUpHorizontally);\n            const canMerge = aligned && rectsTouchOrOverlap(rect1, rect2, tolerance);\n            if (canMerge) {\n                log(`CLIENT RECT: merging two into one, VERTICAL: ${rectsLineUpVertically} HORIZONTAL: ${rectsLineUpHorizontally} (${doNotMergeHorizontallyAlignedRects})`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== rect1 && rect !== rect2;\n                });\n                const replacementClientRect = getBoundingRect(rect1, rect2);\n                newRects.push(replacementClientRect);\n                return mergeTouchingRects(newRects, tolerance, doNotMergeHorizontallyAlignedRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction getBoundingRect(rect1, rect2) {\n    const left = Math.min(rect1.left, rect2.left);\n    const right = Math.max(rect1.right, rect2.right);\n    const top = Math.min(rect1.top, rect2.top);\n    const bottom = Math.max(rect1.bottom, rect2.bottom);\n    return {\n        bottom,\n        height: bottom - top,\n        left,\n        right,\n        top,\n        width: right - left,\n    };\n}\n\nfunction removeContainedRects(rects, tolerance) {\n    const rectsToKeep = new Set(rects);\n    for (const rect of rects) {\n        const bigEnough = rect.width > 1 && rect.height > 1;\n        if (!bigEnough) {\n            log(\"CLIENT RECT: remove tiny\");\n            rectsToKeep.delete(rect);\n            continue;\n        }\n        for (const possiblyContainingRect of rects) {\n            if (rect === possiblyContainingRect) {\n                continue;\n            }\n            if (!rectsToKeep.has(possiblyContainingRect)) {\n                continue;\n            }\n            if (rectContains(possiblyContainingRect, rect, tolerance)) {\n                log(\"CLIENT RECT: remove contained\");\n                rectsToKeep.delete(rect);\n                break;\n            }\n        }\n    }\n    return Array.from(rectsToKeep);\n}\n\nfunction rectContains(rect1, rect2, tolerance) {\n    return (rectContainsPoint(rect1, rect2.left, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.top, tolerance) &&\n        rectContainsPoint(rect1, rect2.left, rect2.bottom, tolerance) &&\n        rectContainsPoint(rect1, rect2.right, rect2.bottom, tolerance));\n}\n\nfunction rectContainsPoint(rect, x, y, tolerance) {\n    return (rect.left < x || almostEqual(rect.left, x, tolerance)) &&\n        (rect.right > x || almostEqual(rect.right, x, tolerance)) &&\n        (rect.top < y || almostEqual(rect.top, y, tolerance)) &&\n        (rect.bottom > y || almostEqual(rect.bottom, y, tolerance));\n}\n\nfunction replaceOverlapingRects(rects) {\n    for (let i = 0; i < rects.length; i++) {\n        for (let j = i + 1; j < rects.length; j++) {\n            const rect1 = rects[i];\n            const rect2 = rects[j];\n            if (rect1 === rect2) {\n                log(\"replaceOverlapingRects rect1 === rect2 ??!\");\n                continue;\n            }\n            if (rectsTouchOrOverlap(rect1, rect2, -1)) {\n                let toAdd = [];\n                let toRemove;\n                let toPreserve;\n                const subtractRects1 = rectSubtract(rect1, rect2);\n                if (subtractRects1.length === 1) {\n                    toAdd = subtractRects1;\n                    toRemove = rect1;\n                    toPreserve = rect2;\n                } else {\n                    const subtractRects2 = rectSubtract(rect2, rect1);\n                    if (subtractRects1.length < subtractRects2.length) {\n                        toAdd = subtractRects1;\n                        toRemove = rect1;\n                        toPreserve = rect2;\n                    } else {\n                        toAdd = subtractRects2;\n                        toRemove = rect2;\n                        toPreserve = rect1;\n                    }\n                }\n                log(`CLIENT RECT: overlap, cut one rect into ${toAdd.length}`);\n                const newRects = rects.filter((rect) => {\n                    return rect !== toRemove;\n                });\n                Array.prototype.push.apply(newRects, toAdd);\n                return replaceOverlapingRects(newRects);\n            }\n        }\n    }\n    return rects;\n}\n\nfunction rectSubtract(rect1, rect2) {\n    const rectIntersected = rectIntersect(rect2, rect1);\n    if (rectIntersected.height === 0 || rectIntersected.width === 0) {\n        return [rect1];\n    }\n    const rects = [];\n    {\n        const rectA = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rect1.left,\n            right: rectIntersected.left,\n            top: rect1.top,\n            width: 0,\n        };\n        rectA.width = rectA.right - rectA.left;\n        rectA.height = rectA.bottom - rectA.top;\n        if (rectA.height !== 0 && rectA.width !== 0) {\n            rects.push(rectA);\n        }\n    }\n    {\n        const rectB = {\n            bottom: rectIntersected.top,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectB.width = rectB.right - rectB.left;\n        rectB.height = rectB.bottom - rectB.top;\n        if (rectB.height !== 0 && rectB.width !== 0) {\n            rects.push(rectB);\n        }\n    }\n    {\n        const rectC = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.left,\n            right: rectIntersected.right,\n            top: rectIntersected.bottom,\n            width: 0,\n        };\n        rectC.width = rectC.right - rectC.left;\n        rectC.height = rectC.bottom - rectC.top;\n        if (rectC.height !== 0 && rectC.width !== 0) {\n            rects.push(rectC);\n        }\n    }\n    {\n        const rectD = {\n            bottom: rect1.bottom,\n            height: 0,\n            left: rectIntersected.right,\n            right: rect1.right,\n            top: rect1.top,\n            width: 0,\n        };\n        rectD.width = rectD.right - rectD.left;\n        rectD.height = rectD.bottom - rectD.top;\n        if (rectD.height !== 0 && rectD.width !== 0) {\n            rects.push(rectD);\n        }\n    }\n    return rects;\n}\n\nfunction rectIntersect(rect1, rect2) {\n    const maxLeft = Math.max(rect1.left, rect2.left);\n    const minRight = Math.min(rect1.right, rect2.right);\n    const maxTop = Math.max(rect1.top, rect2.top);\n    const minBottom = Math.min(rect1.bottom, rect2.bottom);\n    return {\n        bottom: minBottom,\n        height: Math.max(0, minBottom - maxTop),\n        left: maxLeft,\n        right: minRight,\n        top: maxTop,\n        width: Math.max(0, minRight - maxLeft),\n    };\n}\n\nfunction rectsTouchOrOverlap(rect1, rect2, tolerance) {\n    return ((rect1.left < rect2.right || (tolerance >= 0 && almostEqual(rect1.left, rect2.right, tolerance))) &&\n        (rect2.left < rect1.right || (tolerance >= 0 && almostEqual(rect2.left, rect1.right, tolerance))) &&\n        (rect1.top < rect2.bottom || (tolerance >= 0 && almostEqual(rect1.top, rect2.bottom, tolerance))) &&\n        (rect2.top < rect1.bottom || (tolerance >= 0 && almostEqual(rect2.top, rect1.bottom, tolerance))));\n}\n\nfunction almostEqual(a, b, tolerance) {\n    return Math.abs(a - b) <= tolerance;\n}\n\nfunction log() {\n    if (debug) {\n        logNative.apply(null, arguments);\n    }\n}","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\nimport {convertRangeInfo, location2RangeInfo} from \"./selection\";\nimport {getClientRectsNoOverlap} from \"./rect\";\n\nconst debug = false;\n\nconst ID_HIGHLIGHTS_CONTAINER = \"R2_ID_HIGHLIGHTS_CONTAINER\";\nconst CLASS_HIGHLIGHT_CONTAINER = \"R2_CLASS_HIGHLIGHT_CONTAINER\";\nconst CLASS_HIGHLIGHT_AREA = \"R2_CLASS_HIGHLIGHT_AREA\";\nconst CLASS_HIGHLIGHT_BOUNDING_AREA = \"R2_CLASS_HIGHLIGHT_BOUNDING_AREA\";\n\nconst _highlights = [];\nlet _highlightsContainer;\n\nconst defaultBackgroundOpacity = 0.3;\n\nconst defaultBackgroundColor = {\n    blue: 100,\n    green: 50,\n    red: 230,\n};\n\nexport function rectForHighlightWithID(id) {\n    const clientRects = frameForHighlightWithID(id);\n\n    return {\n        screenWidth: window.outerWidth,\n        screenHeight: window.outerHeight,\n        left: clientRects[0].left,\n        width: clientRects[0].width,\n        top: clientRects[0].top,\n        height: clientRects[0].height\n    };\n}\n\nexport function destroyAllHighlights() {\n    hideAllHighlights();\n    _highlights.splice(0, _highlights.length);\n}\n\nfunction hideAllHighlights() {\n    if (_highlightsContainer) {\n        _highlightsContainer.remove();\n        _highlightsContainer = null;\n    }\n}\n\nexport function createHighlightRange(range) {\n\n    // FIXME: Use user-provided ID.\n    let id = \"R2_HIGHLIGHT_\" + Date.now();\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: defaultBackgroundColor,\n        id,\n        pointerInteraction: true,\n        rangeInfo: null\n    };\n    _highlights.push(highlight);\n    createHighlightFromRange(range, highlight);\n\n    return highlight;\n}\n\nexport function createHighlight(locations, color, pointerInteraction) {\n    const rangeInfo = location2RangeInfo(locations)\n\n    // FIXME: Use user-provided ID.\n    let id = \"R2_HIGHLIGHT_\" + Date.now();\n\n    destroyHighlight(id);\n\n    const highlight = {\n        color: color ? color : defaultBackgroundColor,\n        id,\n        pointerInteraction,\n        rangeInfo\n    };\n    _highlights.push(highlight);\n    createHighlightDom(highlight);\n\n    return highlight;\n}\n\nfunction destroyHighlight(id) {\n    let i = -1;\n    let _document = window.document\n    const highlight = _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    });\n    if (highlight && i >= 0 && i < _highlights.length) {\n        _highlights.splice(i, 1);\n    }\n    const highlightContainer = _document.getElementById(id);\n    if (highlightContainer) {\n        highlightContainer.remove();\n    }\n}\n\nfunction createHighlightDom(highlight) {\n    const range = convertRangeInfo(document, highlight.rangeInfo);\n    return createHighlightFromRange(range, highlight)\n}\n\nfunction createHighlightFromRange(range, highlight) {\n    if (!range) {\n        return undefined;\n    }\n\n    const scale = 1 / ((window.READIUM2 && window.READIUM2.isFixedLayout) ? window.READIUM2.fxlViewportScale : 1);\n\n    const scrollElement = document.scrollingElement;\n\n    const paginated = !isScrollModeEnabled()\n    const highlightsContainer = ensureContainer(window);\n    const highlightParent = document.createElement(\"div\");\n\n    highlightParent.setAttribute(\"id\", highlight.id);\n    highlightParent.setAttribute(\"class\", CLASS_HIGHLIGHT_CONTAINER);\n\n    highlightParent.style.setProperty(\"pointer-events\", \"none\");\n    if (highlight.pointerInteraction) {\n        highlightParent.setAttribute(\"data-click\", \"1\");\n    }\n\n    const bodyRect = document.body.getBoundingClientRect();\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    const clientRects = getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects);\n    const roundedCorner = 3;\n    const underlineThickness = 2;\n    const strikeThroughLineThickness = 3;\n    const opacity = defaultBackgroundOpacity;\n    let extra = \"\";\n\n    let xOffset;\n    let yOffset;\n\n    // if (navigator.userAgent.match(/Android/i)) {\n    xOffset = paginated ? (-scrollElement.scrollLeft) : bodyRect.left;\n    yOffset = paginated ? (-scrollElement.scrollTop) : bodyRect.top;\n    // } else if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {\n    //     xOffset = paginated ? 0 : (-scrollElement.scrollLeft);\n    //     yOffset = paginated ? 0 : (bodyRect.top);\n    //     annotationOffset = parseInt((rangeAnnotationBoundingClientRect.right/window.innerWidth) + 1);\n    // }\n\n    for (const clientRect of clientRects) {\n        const highlightArea = document.createElement(\"div\");\n\n        highlightArea.setAttribute(\"class\", CLASS_HIGHLIGHT_AREA);\n\n        if (debug) {\n            const rgb = Math.round(0xffffff * Math.random());\n            const r = rgb >> 16;\n            const g = rgb >> 8 & 255;\n            const b = rgb & 255;\n            extra = `outline-color: rgb(${r}, ${g}, ${b}); outline-style: solid; outline-width: 1px; outline-offset: -1px;`;\n        } else {\n            if (drawUnderline) {\n                extra += `border-bottom: ${underlineThickness * scale}px solid rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important`;\n            }\n        }\n        highlightArea.setAttribute(\"style\", `border-radius: ${roundedCorner}px !important; background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important; ${extra}`);\n        highlightArea.style.setProperty(\"pointer-events\", \"none\");\n        highlightArea.style.position = !paginated ? \"fixed\" : \"absolute\";\n        highlightArea.scale = scale;\n        /*\n         highlightArea.rect = {\n         height: clientRect.height,\n         left: clientRect.left - xOffset,\n         top: clientRect.top - yOffset,\n         width: clientRect.width,\n         };\n         */\n        highlightArea.rect = {\n            height: clientRect.height,\n            left: clientRect.left - xOffset,\n            top: clientRect.top - yOffset,\n            width: clientRect.width\n        };\n\n        highlightArea.style.width = `${highlightArea.rect.width * scale}px`;\n        highlightArea.style.height = `${highlightArea.rect.height * scale}px`;\n        highlightArea.style.left = `${highlightArea.rect.left * scale}px`;\n        highlightArea.style.top = `${highlightArea.rect.top * scale}px`;\n        highlightParent.append(highlightArea);\n        if (!debug && drawStrikeThrough) {\n            //if (drawStrikeThrough) {\n            const highlightAreaLine = document.createElement(\"div\");\n            highlightAreaLine.setAttribute(\"class\", CLASS_HIGHLIGHT_AREA);\n\n            highlightAreaLine.setAttribute(\"style\", `background-color: rgba(${highlight.color.red}, ${highlight.color.green}, ${highlight.color.blue}, ${opacity}) !important;`);\n            highlightAreaLine.style.setProperty(\"pointer-events\", \"none\");\n            highlightAreaLine.style.position = paginated ? \"fixed\" : \"absolute\";\n            highlightAreaLine.scale = scale;\n            /*\n             highlightAreaLine.rect = {\n             height: clientRect.height,\n             left: clientRect.left - xOffset,\n             top: clientRect.top - yOffset,\n             width: clientRect.width,\n             };\n             */\n\n            highlightAreaLine.rect = {\n                height: clientRect.height,\n                left: clientRect.left - xOffset,\n                top: clientRect.top - yOffset,\n                width: clientRect.width\n            };\n\n            highlightAreaLine.style.width = `${highlightAreaLine.rect.width * scale}px`;\n            highlightAreaLine.style.height = `${strikeThroughLineThickness * scale}px`;\n            highlightAreaLine.style.left = `${highlightAreaLine.rect.left * scale}px`;\n            highlightAreaLine.style.top = `${(highlightAreaLine.rect.top + (highlightAreaLine.rect.height / 2) - (strikeThroughLineThickness / 2)) * scale}px`;\n            highlightParent.append(highlightAreaLine);\n        }\n    }\n\n    const highlightBounding = document.createElement(\"div\");\n    highlightBounding.setAttribute(\"class\", CLASS_HIGHLIGHT_BOUNDING_AREA);\n\n    highlightBounding.style.setProperty(\"pointer-events\", \"none\");\n    highlightBounding.style.position = paginated ? \"fixed\" : \"absolute\";\n    highlightBounding.scale = scale;\n\n    if (debug) {\n        highlightBounding.setAttribute(\"style\", `outline-color: magenta; outline-style: solid; outline-width: 1px; outline-offset: -1px;`);\n    }\n\n    const rangeBoundingClientRect = range.getBoundingClientRect();\n    highlightBounding.rect = {\n        height: rangeBoundingClientRect.height,\n        left: rangeBoundingClientRect.left - xOffset,\n        top: rangeBoundingClientRect.top - yOffset,\n        width: rangeBoundingClientRect.width\n    };\n\n    highlightBounding.style.width = `${highlightBounding.rect.width * scale}px`;\n    highlightBounding.style.height = `${highlightBounding.rect.height * scale}px`;\n    highlightBounding.style.left = `${highlightBounding.rect.left * scale}px`;\n    highlightBounding.style.top = `${highlightBounding.rect.top * scale}px`;\n\n    highlightParent.append(highlightBounding);\n    highlightsContainer.append(highlightParent);\n\n    return highlightParent;\n}\n\nfunction isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue(\"--USER__scroll\").toString().trim() === 'readium-scroll-on';\n}\n\nfunction ensureContainer(win) {\n    const document = win.document;\n\n    if (!_highlightsContainer) {\n        _highlightsContainer = document.createElement(\"div\");\n        _highlightsContainer.setAttribute(\"id\", ID_HIGHLIGHTS_CONTAINER);\n\n        _highlightsContainer.style.setProperty(\"pointer-events\", \"none\");\n        document.body.append(_highlightsContainer);\n    }\n\n    return _highlightsContainer;\n}\n\nfunction frameForHighlightWithID(id) {\n    const highlight = highlightWithID(id);\n    if (!highlight)\n        return;\n\n    const document = window.document;\n    const range = convertRangeInfo(document, highlight.rangeInfo);\n    if (!range) {\n        return undefined;\n    }\n\n\n    const drawUnderline = false;\n    const drawStrikeThrough = false;\n    const doNotMergeHorizontallyAlignedRects = drawUnderline || drawStrikeThrough;\n    return getClientRectsNoOverlap(range, doNotMergeHorizontallyAlignedRects);\n}\n\nfunction highlightWithID(id) {\n    let i = -1;\n    return _highlights.find((h, j) => {\n        i = j;\n        return h.id === id;\n    })\n}","import approxSearch from 'approx-string-match';\n\n/**\n * @typedef {import('approx-string-match').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn't currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return approxSearch(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n */\nfunction textMatchScore(text, str) {\n  /* istanbul ignore next - `scoreMatch` will never pass an empty string */\n  if (str.length === 0) {\n    return 0.0;\n  }\n  const matches = search(text, str, str.length);\n\n  // prettier-ignore\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nexport function matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of \"good\" matches found)\n  //  - Precision (proportion of matches found which are \"good\")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(match.start - context.prefix.length, match.start),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === 'number') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n","/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don't need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n    if (length + textNode.data.length > nextOffset) {\n      results.push({ node: textNode, offset: nextOffset - length });\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && textNode && length === nextOffset) {\n    results.push({ node: textNode, offset: textNode.data.length });\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError('Offset exceeds text length');\n  }\n\n  return results;\n}\n\nexport let RESOLVE_FORWARDS = 1;\nexport let RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nexport class TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error('Offset is invalid');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element's `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error('Parent is not an ancestor of current element');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element's text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return { node: text, offset: forwards ? 0 : text.data.length };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error('Node is not an element or text node');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error('Text node offset is out of range');\n        }\n\n        if (!node.parentElement) {\n          throw new Error('Text node has no parent');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error('Child node offset is out of range');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error('Point is not in an element or text node');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don't affect its text content, without affecting the text content\n * of the range itself.\n */\nexport class TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   */\n  relativeTo(element) {\n    return new TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to \"shrink\" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({ direction: RESOLVE_FORWARDS });\n      end = this.end.resolve({ direction: RESOLVE_BACKWARDS });\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  static fromOffsets(root, start, end) {\n    return new TextRange(\n      new TextPosition(root, start),\n      new TextPosition(root, end)\n    );\n  }\n}\n","/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n */\n\nimport { matchQuote } from './match-quote';\nimport { TextRange, TextPosition } from './text-range';\nimport { nodeFromXPath, xpathFromNode } from './xpath';\n\n/**\n * @typedef {import('../../types/api').RangeSelector} RangeSelector\n * @typedef {import('../../types/api').TextPositionSelector} TextPositionSelector\n * @typedef {import('../../types/api').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nexport class RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    if (!startContainer) {\n      throw new Error('Failed to resolve startContainer XPath');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error('Failed to resolve endContainer XPath');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // \"Shrink\" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: 'RangeSelector',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nexport class TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextPositionSelector',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nexport class TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextQuoteSelector',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n    if (!match) {\n      throw new Error('Quote not found');\n    }\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Catch JS errors to log them in the app.\n\nimport {createHighlightRange} from \"./highlight\";\nimport {TextQuoteAnchor} from \"./vendor/hypothesis/anchoring/types\";\n\nwindow.addEventListener(\"error\", function(event) {\n    webkit.messageHandlers.logError.postMessage({\n        \"message\": event.message,\n        \"filename\": event.filename,\n        \"line\": event.lineno\n    });\n}, false);\n\n// Notify native code that the page has loaded.\nwindow.addEventListener(\"load\", function(){ // on page load\n    window.addEventListener(\"orientationchange\", function() {\n        orientationChanged();\n        snapCurrentPosition();\n    });\n    orientationChanged();\n}, false);\n\nvar last_known_scrollX_position = 0;\nvar last_known_scrollY_position = 0;\nvar ticking = false;\nvar maxScreenX = 0;\n\n// Position in range [0 - 1].\nfunction update(position) {\n    var positionString = position.toString()\n    webkit.messageHandlers.progressionChanged.postMessage(positionString);\n}\n\nwindow.addEventListener('scroll', function(e) {\n    last_known_scrollY_position = window.scrollY / document.scrollingElement.scrollHeight;\n    // Using Math.abs because for RTL books, the value will be negative.\n    last_known_scrollX_position = Math.abs(window.scrollX / document.scrollingElement.scrollWidth);\n\n    // Window is hidden\n    if (document.scrollingElement.scrollWidth === 0 || document.scrollingElement.scrollHeight === 0) {\n        return;\n    }\n\n    if (!ticking) {\n        window.requestAnimationFrame(function() {\n            update(isScrollModeEnabled() ? last_known_scrollY_position : last_known_scrollX_position);\n            ticking = false;\n        });\n    }\n    ticking = true;\n});\n\ndocument.addEventListener('selectionchange', debounce(50, function() {\n    var info = {}\n    var selection = document.getSelection();\n    if (selection && selection.rangeCount > 0) {\n        var rect = selection.getRangeAt(0).getBoundingClientRect();\n        info['text'] = selection.toString().trim();\n        info['frame'] = {\n            'x': rect.left,\n            'y': rect.top,\n            'width': rect.width,\n            'height': rect.height\n        };\n    }\n\n    webkit.messageHandlers.selectionChanged.postMessage(info);\n}));\n\nfunction orientationChanged() {\n    maxScreenX = (window.orientation === 0 || window.orientation == 180) ? screen.width : screen.height;\n}\n\nfunction isScrollModeEnabled() {\n    return document.documentElement.style.getPropertyValue(\"--USER__scroll\").toString().trim() === 'readium-scroll-on';\n}\n\n// Scroll to the given TagId in document and snap.\nexport function scrollToId(id) {\n    var element = document.getElementById(id);\n    if (!element) {\n        return false;\n    }\n    element.scrollIntoView();\n\n    if (!isScrollModeEnabled()) {\n        var currentOffset = window.scrollX;\n        var pageWidth = window.innerWidth;\n        // Adds half a page to make sure we don't snap to the previous page.\n        document.scrollingElement.scrollLeft = snapOffset(currentOffset + (pageWidth / 2));\n    }\n    return true;\n}\n\n// Position must be in the range [0 - 1], 0-100%.\nexport function scrollToPosition(position, dir) {\n    console.log(\"ScrollToPosition\");\n    if ((position < 0) || (position > 1)) {\n        console.log(\"InvalidPosition\");\n        return;\n    }\n\n    if (isScrollModeEnabled()) {\n        var offset = document.scrollingElement.scrollHeight * position;\n        document.scrollingElement.scrollTop = offset;\n        // window.scrollTo(0, offset);\n    } else {\n        var documentWidth = document.scrollingElement.scrollWidth;\n        var factor = (dir == 'rtl') ? -1 : 1;\n        var offset = documentWidth * position * factor;\n        document.scrollingElement.scrollLeft = snapOffset(offset);\n    }\n}\n\n// Scrolls to the first occurrence of the given text snippet.\n//\n// The expected text argument is a Locator Text object, as defined here:\n// https://readium.org/architecture/models/locators/\nexport function scrollToText(text) {\n    // try {\n        log(text)\n        let anchor = new TextQuoteAnchor(document.body, text.highlight, {\n            prefix: text.before,\n            suffix: text.after,\n        })\n\n        scrollToRange(anchor.toRange())\n        return true\n    // } catch (e) {\n    //     logException(e)\n    //     return false\n    // }\n}\n\nfunction scrollToRange(range) {\n    var rect = range.getBoundingClientRect();\n    if (isScrollModeEnabled()) {\n        document.scrollingElement.scrollTop = rect.top + window.scrollY - (window.innerHeight / 2);\n    } else {\n        document.scrollingElement.scrollLeft = rect.left + window.scrollX;\n        snapCurrentPosition();\n    }\n\n    createHighlightRange(range)\n}\n\n// Returns false if the page is already at the left-most scroll offset.\nexport function scrollLeft(dir) {\n    var isRTL = (dir == \"rtl\");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX - pageWidth;\n    var minOffset = isRTL ? -(documentWidth - pageWidth) : 0;\n    return scrollToOffset(Math.max(offset, minOffset));\n}\n\n// Returns false if the page is already at the right-most scroll offset.\nexport function scrollRight(dir) {\n    var isRTL = (dir == \"rtl\");\n    var documentWidth = document.scrollingElement.scrollWidth;\n    var pageWidth = window.innerWidth;\n    var offset = window.scrollX + pageWidth;\n    var maxOffset = isRTL ? 0 : (documentWidth - pageWidth);\n    return scrollToOffset(Math.min(offset, maxOffset));\n}\n\n// Scrolls to the given left offset.\n// Returns false if the page scroll position is already close enough to the given offset.\nfunction scrollToOffset(offset) {\n    var currentOffset = window.scrollX;\n    var pageWidth = window.innerWidth;\n    document.scrollingElement.scrollLeft = offset;\n    // In some case the scrollX cannot reach the position respecting to innerWidth\n    var diff = Math.abs(currentOffset - offset) / pageWidth;\n    return (diff > 0.01);\n}\n\n// Snap the offset to the screen width (page width).\nfunction snapOffset(offset) {\n    var value = offset + 1;\n\n    return value - (value % maxScreenX);\n}\n\nfunction snapCurrentPosition() {\n    if (isScrollModeEnabled()) {\n        return;\n    }\n    var currentOffset = window.scrollX;\n    var currentOffsetSnapped = snapOffset(currentOffset + 1);\n\n    document.scrollingElement.scrollLeft = currentOffsetSnapped;\n}\n\n/// User Settings.\n\n// For setting user setting.\nexport function setProperty(key, value) {\n    var root = document.documentElement;\n\n    root.style.setProperty(key, value);\n}\n\n// For removing user setting.\nexport function removeProperty(key) {\n    var root = document.documentElement;\n\n    root.style.removeProperty(key);\n}\n\n\n/// Toolkit\n\nfunction debounce(delay, func) {\n    var timeout;\n    return function() {\n        var self = this;\n        var args = arguments;\n        function callback() {\n            func.apply(self, args);\n            timeout = null;\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(callback, delay);\n    };\n}\n\nexport function log() {\n    var message = Array.prototype.slice.call(arguments).join(\" \");\n    webkit.messageHandlers.log.postMessage(message);\n}\n\nexport function logException(e) {\n    webkit.messageHandlers.logError.postMessage({\n        \"message\": e.message\n    });\n}\n","//\n//  Copyright 2021 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\n\n// Base script used by both reflowable and fixed layout resources.\n\nimport './gestures'\nimport {removeProperty, scrollLeft, scrollRight, scrollToId, scrollToPosition, scrollToText, setProperty} from \"./utils\";\nimport {getCurrentSelectionInfo, getSelectionRect} from \"./selection\";\nimport {createHighlight, createHighlightRange} from \"./highlight\";\nimport {TextQuoteAnchor} from \"./vendor/hypothesis/anchoring/types\";\n\n\n// Public API used by the navigator.\nwindow.readium = {\n    // utils\n    'scrollToId': scrollToId,\n    'scrollToPosition': scrollToPosition,\n    'scrollToText': scrollToText,\n    'scrollLeft': scrollLeft,\n    'scrollRight': scrollRight,\n    'setProperty': setProperty,\n    'removeProperty': removeProperty,\n\n    // selection\n    'getSelectionRect': getSelectionRect,\n    'getCurrentSelectionInfo': getCurrentSelectionInfo,\n\n    // highlights\n    'createHighlight': createHighlight,\n    'createHighlightRange': createHighlightRange,\n\n    // Hypothesis' anchoring\n    'TextQuoteAnchor': TextQuoteAnchor,\n};"],"sourceRoot":""}